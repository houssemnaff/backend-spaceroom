const Course = require("../models/course");
const User = require("../models/user");
const crypto = require("crypto");



const { uploadImage } = require('../utils/imageUpload');  // Adjust the path accordingly
const course = require("../models/course");
const Chapter = require("../models/chapter");
const ressource = require("../models/ressource");
const sendEmail = require("./emailcontroller");
const UserProgress = require("../models/UserProgress");

exports.createCourse = async (req, res) => {
    try {
        // Log the incoming request body for debugging
       // console.log('Request Body:', req.body);
        
       //console.log('Uploaded File:', req.file);

        // Ensure title and description are included in the request body
        if (!req.body.title || !req.body.description) {
            return res.status(400).json({ message: 'Title and description are required' });
        }

        // Upload the image and get the URL from Cloudinary
        const imageurl = await uploadImage(req);  // Now returning image URL directly

        if (!imageurl) {
            return res.status(400).json({ message: 'Image upload failed or no image uploaded' });
        }

        // Generate a unique access key for the course
        const accessKey = crypto.randomBytes(4).toString('hex');

        // Create new course with image URL and other details
        const newCourse = new Course({
            title: req.body.title,
            description: req.body.description,
            imageurl,  // Image URL from Cloudinary
            accessKey,
            owner: req.user.id  // Assuming the user is authenticated
        });

        await newCourse.save();

        // Update the user's createdCourses list
        await User.findByIdAndUpdate(req.user.id, {
            $push: { createdCourses: newCourse._id }
        });


        res.status(201).json({ message: 'Course created successfully', course: newCourse });
    } catch (error) {
        console.error('Server error: ', error);
        res.status(500).json({ message: 'Server error', error: error.message || error });
    }
};


// ğŸ“Œ Rejoindre un cours avec une clÃ© d'accÃ¨s
exports.joinCourse = async (req, res) => {
    try {
        const { accessKey } = req.body;
        const course = await Course.findOne({ accessKey });

        if (!course) {
            return res.status(404).json({ message: "ClÃ© d'accÃ¨s incorrecte ou cours introuvable" });
        }

        if (course.owner.toString() === req.user.id) {
            return res.status(400).json({ message: "Vous ne pouvez pas rejoindre votre propre cours" });
        }

        if (course.students.includes(req.user.id)) {
            return res.status(400).json({ message: "Vous avez dÃ©jÃ  rejoint ce cours" });
        }

        // Add the user to the course
        course.students.push(req.user.id);
        await course.save();

        // Add the course to the user's enrolled courses
        const user = await User.findById(req.user.id);
        user.enrolledCourses.push(course._id);
        await user.save();

        res.status(200).json({
            message: "Vous avez rejoint le cours avec succÃ¨s",
        });

    } catch (error) {
        console.error("Erreur serveur : ", error);
        res.status(500).json({ message: "Erreur serveur", error: error.message || error });
    }
};


// ğŸ“Œ 3. Ajouter une ressource Ã  un cours
exports.addResource = async (req, res) => {
    try {
        const { courseId } = req.params;
        const { type, url, name } = req.body;

        const course = await Course.findById(courseId);
        if (!course) return res.status(404).json({ message: "Cours introuvable" });

        if (course.owner.toString() !== req.user.id)
            return res.status(403).json({ message: "Vous n'Ãªtes pas autorisÃ© Ã  ajouter des ressources" });

        course.resources.push({ type, url, name });
        await course.save();

        res.status(200).json({ message: "Ressource ajoutÃ©e", course });
    } catch (error) {
        res.status(500).json({ message: "Erreur serveur", error });
    }
};
// ğŸ“Œ 4. RÃ©cupÃ©rer les cours crÃ©Ã©s par un utilisateur
exports.getMyCourses = async (req, res) => {
    try {
        // Trouver uniquement les cours oÃ¹ l'utilisateur est le propriÃ©taire
        const courses = await Course.find({ owner: req.user.id }).populate("owner", "name email");
       
        res.status(200).json({ courses });
    } catch (error) {
        res.status(500).json({ message: "Erreur serveur", error });
    }
};


// ğŸ“Œ RÃ©cupÃ©rer les cours rejoints par l'utilisateur
exports.getJoinedCourses = async (req, res) => {
    try {
        const joinedCourses = await Course.find({ students: req.user.id }).populate("owner", "name email");
        res.status(200).json({ joinedCourses });
    } catch (error) {
        res.status(500).json({ message: "Erreur serveur", error });
    }
};



// ğŸ“Œ 5. Supprimer un cours (uniquement par son crÃ©ateur) ainsi que ses chapitres et ressources
exports.deleteCourse = async (req, res) => {
    try {
        const { courseId } = req.params;

        // Trouver le cours
        const course = await Course.findById(courseId);
        if (!course) {
            return res.status(404).json({ message: "Cours introuvable" });
        }

        // VÃ©rifier si l'utilisateur est le propriÃ©taire du cours
        if (course.owner.toString() !== req.user.id) {
            return res.status(403).json({ message: "Vous n'Ãªtes pas autorisÃ© Ã  supprimer ce cours" });
        }

        // Trouver tous les chapitres associÃ©s au cours
        const chapters = await Chapter.find({ course: courseId });

        // Supprimer toutes les ressources associÃ©es Ã  ces chapitres
        for (const chapter of chapters) {
            await Ressource.deleteMany({ chapter: chapter._id });
        }

        // Supprimer tous les chapitres associÃ©s au cours
        await Chapter.deleteMany({ course: courseId });

        // Supprimer le cours lui-mÃªme
        await Course.deleteOne({ _id: courseId });

        res.status(200).json({ message: "Cours, chapitres et ressources supprimÃ©s avec succÃ¨s" });
    } catch (error) {
        console.error("Erreur lors de la suppression du cours :", error);
        res.status(500).json({ message: "Erreur serveur", error: error.message });
    }
};
const Resource = require("../models/ressource");
const { default: mongoose } = require("mongoose");
/*
exports.deleteResource = async (req, res) => {
  console.log("resourceId");
  try {
    const { courseId, resourceId } = req.params;
    console.log("resourceId",resourceId);

    // VÃ©rifie si le cours existe
    const course = await Course.findById(courseId);
    if (!course) {
      return res.status(404).json({ message: "Cours introuvable" });
    }

    // VÃ©rifie que l'utilisateur est bien le propriÃ©taire
    if (course.owner.toString() !== req.user.id) {
      return res.status(403).json({ message: "Non autorisÃ©" });
    }

    // Supprime la ressource du tableau `resources` du cours
    course.resources = course.resources.filter(
      (resource) => resource._id.toString() !== resourceId
    );
    await course.save();

    // Supprime l'objet Resource de la collection
    await Resource.findByIdAndDelete(resourceId);

   // ğŸ”¥ TrÃ¨s important : convertir resourceId en ObjectId
   const resourceObjectId = new mongoose.Types.ObjectId(resourceId);
console.log("resourceId",resourceId);
console.log("resourceObjectId",resourceObjectId);

   // Supprimer la ressource dans UserProgress de tous les Ã©tudiants
   await UserProgress.updateMany(
     { courseId },
     { $pull: { viewedResources: resourceObjectId } }
   );

    res.status(200).json({ message: "Ressource supprimÃ©e et progression mise Ã  jour", course });

  } catch (error) {
    console.error("Erreur lors de la suppression de la ressource:", error);
    res.status(500).json({ message: "Erreur serveur", error });
  }
};
*/


exports.getCourseDetails = async (req, res) => {
    console.log("Fonction getCourseDetails appelÃ©e"); // Log pour vÃ©rifier que la fonction est appelÃ©e

    try {
        const { courseId } = req.params; // RÃ©cupÃ©rer le courseId depuis les paramÃ¨tres de l'URL
        console.log("ID du cours reÃ§u :", courseId); // Log pour vÃ©rifier l'ID reÃ§u

        if (!courseId) {
            return res.status(400).json({ message: "courseId est requis" });
        }

        // Trouver le cours par ID et peupler les informations du propriÃ©taire et des Ã©tudiants
        const course = await Course.findById(courseId)
            .populate("owner", "name email") // Peupler les informations du propriÃ©taire
            .populate("students", "name email"); // Peupler les informations des Ã©tudiants

        if (!course) {
            return res.status(404).json({ message: "Cours non trouvÃ©" });
        }

        res.status(200).json({ message: "DÃ©tails du cours rÃ©cupÃ©rÃ©s avec succÃ¨s", course });
    } catch (error) {
        console.error("Erreur serveur : ", error);
        res.status(500).json({ message: "Erreur serveur", error: error.message || error });
    }
};
// ğŸ”¹ RÃ©cupÃ©rer la liste des Ã©tudiants inscrits Ã  un cours
exports.getcourstudents = async (req, res) => {
    try {
      const course = await Course.findById(req.params.courseId).populate("students", "name email");
      if (!course) return res.status(404).json({ message: "Cours non trouvÃ©" });
  
      res.json({ students: course.students });
    } catch (error) {
      console.error(error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  };
  
  // ğŸ”¹ Supprimer un Ã©tudiant du cours
  exports.deletestudentfromcour =async (req, res) => {
    try {
      const { courseId, studentId } = req.params;
  
      const course = await Course.findById(courseId);
      if (!course) return res.status(404).json({ message: "Cours non trouvÃ©" });
  
      // Supprimer l'Ã©tudiant du tableau `students`
      course.students = course.students.filter((id) => id.toString() !== studentId);
      await course.save();
  
      res.json({ message: "Ã‰tudiant supprimÃ© du cours" });
    } catch (error) {
      console.error(error);
      res.status(500).json({ message: "Erreur serveur" });
    }
  };

  exports.joincourlink = async (req, res) => {
    try {
        const accessKey = req.params.accessKey || req.query.accessKey;
        console.log("Received accessKey:", accessKey);

        if (!accessKey) {
            return res.status(400).json({ message: "La clÃ© d'accÃ¨s est requise" });
        }

        // Trouver le cours via la clÃ© d'accÃ¨s
        const course = await Course.findOne({ accessKey });

        if (!course) {
            return res.status(404).json({ message: "Cours introuvable" });
        }

        // VÃ©rifier si l'utilisateur est authentifiÃ©
        if (!req.user) {
            return res.status(401).json({
                message: "Vous devez Ãªtre connectÃ© pour rejoindre un cours",
                redirectUrl: `http://localhost:5173/login?redirect_url=http://localhost:5173/course/join/${accessKey}`,
            });
        }

        // VÃ©rifier si l'utilisateur est dÃ©jÃ  inscrit
        if (course.students.includes(req.user.id)) {
            return res.status(400).json({ message: "Vous avez dÃ©jÃ  rejoint ce cours" });
        }

        // Ajouter l'utilisateur Ã  la liste des Ã©tudiants
        course.students.push(req.user.id);
        await course.save();

        // Mettre Ã  jour l'utilisateur pour inclure ce cours
        await User.findByIdAndUpdate(req.user.id, {
            $push: { enrolledCourses: course._id }
        });

        res.status(200).json({
            message: "Vous avez rejoint le cours avec succÃ¨s",
            course
        });

    } catch (error) {
        console.error("Erreur serveur : ", error);
        res.status(500).json({ message: "Erreur serveur", error: error.message || error });
    }
};



// Ajouter cette fonction dans le fichier controllers/courseController.js


// ğŸ”¹ Inviter un Ã©tudiant par email Ã  rejoindre un cours
exports.inviteStudentToCourse = async (req, res) => {
  try {
    const { courseId } = req.params;
    const { email } = req.body;

    if (!email) {
      return res.status(400).json({ message: "L'adresse email est requise" });
    }

    // VÃ©rifier le format de l'email
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      return res.status(400).json({ message: "Format d'email invalide" });
    }

    // Trouver le cours
    const course = await Course.findById(courseId);
    if (!course) {
      return res.status(404).json({ message: "Cours introuvable" });
    }

    // VÃ©rifier que l'utilisateur est le propriÃ©taire du cours
    if (course.owner.toString() !== req.user.id) {
      return res.status(403).json({ 
        message: "Vous n'Ãªtes pas autorisÃ© Ã  inviter des Ã©tudiants Ã  ce cours" 
      });
    }

    // Trouver l'information du propriÃ©taire (professeur)
    const professor = await User.findById(req.user.id, "name email");
    if (!professor) {
      return res.status(404).json({ message: "Informations du professeur introuvables" });
    }

    // CrÃ©er le lien d'invitation avec la clÃ© d'accÃ¨s du cours
    const inviteLink = `${process.env.FRONTEND_URL || 'http://localhost:5173'}/course/join/${course.accessKey}`;
    
    // PrÃ©parer le contenu de l'email
    const emailContent = {
      from: `"${professor.name}" <${professor.email}>`,
      to: email,
      subject: `Invitation Ã  rejoindre le cours "${course.title}"`,
      text: `
Bonjour,

Vous avez Ã©tÃ© invitÃ©(e) par ${professor.name} (${professor.email}) Ã  rejoindre le cours "${course.title}".

Pour rejoindre ce cours, veuillez cliquer sur le lien suivant:
${inviteLink}

Cordialement,
L'Ã©quipe de la plateforme de cours
      `,
      html: `
<!DOCTYPE html>
<html>
<head>
  <style>
    body { font-family: Arial, sans-serif; line-height: 1.6; }
    .container { max-width: 600px; margin: 0 auto; padding: 20px; }
    .header { background-color: #4A90E2; color: white; padding: 10px 20px; text-align: center; }
    .content { padding: 20px; background-color: #f9f9f9; }
    .button { background-color: #4A90E2; color: white; padding: 10px 20px; text-decoration: none; display: inline-block; border-radius: 5px; }
    .footer { text-align: center; margin-top: 20px; font-size: 12px; color: #666; }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h2>Invitation Ã  rejoindre un cours</h2>
    </div>
    <div class="content">
      <p>Bonjour,</p>
      <p>Vous avez Ã©tÃ© invitÃ©(e) par <strong>${professor.name}</strong> (<a href="mailto:${professor.email}">${professor.email}</a>) Ã  rejoindre le cours :</p>
      <h3>"${course.title}"</h3>
      <p>Pour accÃ©der Ã  ce cours, veuillez cliquer sur le bouton ci-dessous :</p>
      <p style="text-align: center;">
        <a href="${inviteLink}" class="button">Rejoindre le cours</a>
      </p>
      <p>Ou copiez et collez ce lien dans votre navigateur :</p>
      <p>${inviteLink}</p>
    </div>
    <div class="footer">
      <p>Ceci est un message automatique, merci de ne pas y rÃ©pondre.</p>
    </div>
  </div>
</body>
</html>
      `
    };

    // Envoyer l'email
    await sendEmail(emailContent);

    res.status(200).json({ 
      message: "Invitation envoyÃ©e avec succÃ¨s",
      inviteLink
    });
    
  } catch (error) {
    console.error("Erreur lors de l'envoi de l'invitation:", error);
    res.status(500).json({ 
      message: "Erreur lors de l'envoi de l'invitation", 
      error: error.message || error 
    });
  }
};
// ğŸ“Œ Mettre Ã  jour un cours
exports.updateCourse = async (req, res) => {
    try {
      const { courseId } = req.params;
      
      // DÃ©boguer ce que le backend reÃ§oit
      console.log("Backend received body:", req.body);
      console.log("Backend received files:", req.file);
      
      // RÃ©cupÃ©rer le title et description du formulaire 
      // ou utiliser les valeurs existantes si non fournis
      const title = req.body.title;
      const description = req.body.description;
      
      console.log("Traitement des donnÃ©es:", title, description);
      
      // VÃ©rifier si le cours existe
      const course = await Course.findById(courseId);
      if (!course) {
        return res.status(404).json({ message: "Cours introuvable" });
      }
      
      // VÃ©rifier si l'utilisateur est le propriÃ©taire du cours
      if (course.owner.toString() !== req.user.id) {
        return res.status(403).json({ message: "Vous n'Ãªtes pas autorisÃ© Ã  modifier ce cours" });
      }
      
      // PrÃ©parer les donnÃ©es de mise Ã  jour en utilisant les valeurs existantes 
      // si les nouvelles ne sont pas fournies
      const updateData = {};
      
      // N'ajouter que les champs qui sont dÃ©finis
      if (title !== undefined) {
        updateData.title = title;
      }
      
      if (description !== undefined) {
        updateData.description = description;
      }
      
      // Si une nouvelle image est fournie, la tÃ©lÃ©charger
      if (req.file) {
        const imageurl = await uploadImage(req);
        if (imageurl) {
          updateData.imageurl = imageurl;
        }
      }
      
      console.log("DonnÃ©es finales pour mise Ã  jour:", updateData);
      
      // Mettre Ã  jour le cours seulement avec les champs qui ont Ã©tÃ© fournis
      const updatedCourse = await Course.findByIdAndUpdate(
        courseId,
        updateData,
        { new: true }
      ).populate("owner", "name email");
      
      res.status(200).json({
        message: "Cours mis Ã  jour avec succÃ¨s",
        course: updatedCourse
      });
    } catch (error) {
      console.error("Erreur lors de la mise Ã  jour du cours :", error);
      res.status(500).json({ message: "Erreur serveur", error: error.message || error });
    }
  };